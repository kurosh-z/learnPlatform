import React, { useRef, useEffect } from 'react';
import {
  Engine,
  Scene,
  Color4,
  Color3,
  ArcRotateCamera,
  Vector3,
  Mesh,
  VertexBuffer
} from '@babylonjs/core';
import { css as emoCSS } from '@emotion/core';
import { useTheme } from 'emotion-theming';
import { Theme } from '../theme/types';

interface SceneArgs {
  canvas: HTMLCanvasElement;
  engine: Engine;
}

const createScene: ({ canvas, engine }: SceneArgs) => Scene = function({
  canvas,
  engine
}) {
  var scene = new Scene(engine);
  var camera = new ArcRotateCamera(
    'camera1',
    0,
    0,
    10,
    new Vector3(0, 0, 0),
    scene
  );

  camera.setPosition(new Vector3(20, 200, 400));
  camera.maxZ = 20000;
  camera.lowerRadiusLimit = 150;
  if (canvas) camera.attachControl(canvas, true);
  scene.clearColor = new Color4(0, 0, 0);

  // create Whirpool
  var points = [];
  var radius = 0.5;
  var angle = 0;
  for (var index = 0; index < 1000; index++) {
    points.push(
      new Vector3(radius * Math.cos(angle), 0, radius * Math.sin(angle))
    );
    radius += 0.3;
    angle += 0.1;
  }
  var whirlpool = Mesh.CreateLines('whirlpool', points, scene, true);
  whirlpool.color = new Color3(1, 1, 1);

  var positionData = whirlpool.getVerticesData(VertexBuffer.PositionKind);
  var heightRange = 10;
  var alpha = 0;

  scene.registerBeforeRender(function() {
    if (!positionData) return;
    for (var index = 0; index < 1000; index++) {
      positionData[index * 3 + 1] = heightRange * Math.sin(alpha + index * 0.1);
    }
    whirlpool.updateVerticesData(VertexBuffer.PositionKind, positionData);
    alpha += 0.05 * scene.getAnimationRatio();
  });

  return scene;
};

const Probability01: React.FC<{}> = () => {
  const theme = useTheme<Theme>();
  const prob = emoCSS({
    backgroundColor: theme.palette.white.base,
    color: theme.palette.gray.base,
    width: '100vw',
    height: '100vh'
  });

  const pCanv = useRef<HTMLCanvasElement | null>(null);

  useEffect(() => {
    var canvas = pCanv.current;
    var engine = new Engine(canvas, true);
    if (canvas) {
      var scene = createScene({ canvas, engine });
      engine.runRenderLoop(function() {
        scene.render();
      });
    }
  }, [pCanv]);

  return (
    <div css={prob}>
      <h1> probability 01</h1>
      <canvas
        className='pCanv'
        style={{ width: '50%', height: '50%', margin: '10% ' }}
        ref={el => {
          pCanv.current = el;
        }}
      />
    </div>
  );
};

export default Probability01;
